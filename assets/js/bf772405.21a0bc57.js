"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6342],{73743:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=t(74848),i=t(15680);const s={},o="Digest Kinds",a={id:"rfcs/drafts/digest-kinds",title:"Digest Kinds",description:"Use cases:",source:"@site/../docs/rfcs/drafts/digest-kinds.md",sourceDirName:"rfcs/drafts",slug:"/rfcs/drafts/digest-kinds",permalink:"/docs/rfcs/drafts/digest-kinds",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{}},l={},c=[{value:"Use cases:",id:"use-cases",level:2},{value:"Proposed plan",id:"proposed-plan",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Hashes received from RE",id:"hashes-received-from-re",level:3},{value:"Hashes of files",id:"hashes-of-files",level:3},{value:"Hashes of directories",id:"hashes-of-directories",level:3}];function h(e){const n={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,i.useMDXComponents)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"digest-kinds",children:"Digest Kinds"})}),"\n",(0,r.jsx)(n.h2,{id:"use-cases",children:"Use cases:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Buck2 needs to support more than just SHA1 for open-sourcing, since publicly\navailable RE providers use SHA256."}),"\n",(0,r.jsx)(n.li,{children:"Internally, we want to migrate to (potentially keyed) Blake3, and there will\nbe a transition period where we need to support both Blake3 and SHA1."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"proposed-plan",children:"Proposed plan"}),"\n",(0,r.jsxs)(n.p,{children:["Make all the ways in which Buck2 ",(0,r.jsx)(n.em,{children:"ingests"})," digests either configurable or\nexplicit about the type of digest they expect."]}),"\n",(0,r.jsxs)(n.p,{children:["Internally, we may keep track of digest types for debugging purposes, but we\nwill never compute more than one digest. It follows that we won't expose\nconfiguration for the digests we ",(0,r.jsx)(n.em,{children:"output"})," (namely: to use on RE): if we only\nhave one digest for each blob, making it configurable has no utility since you\nnever have a choice about the hash to use."]}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"hashes-received-from-re",children:"Hashes received from RE"}),"\n",(0,r.jsx)(n.p,{children:"For interactions with RE, we'll expose two configurations (this can be on the\nCommandExecutorConfig):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Preferred hash to use when Buck2 is doing the hashing (e.g. hashing\ndirectories)."}),"\n",(0,r.jsx)(n.li,{children:"Accepted hashes."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We'll use the format of the digests we receive from RE (in particular their\nsize) to infer what algorithm they used (remember: the RE API provides no way of\nknowing the format of a digest, it's just a string)."}),"\n",(0,r.jsx)(n.h3,{id:"hashes-of-files",children:"Hashes of files"}),"\n",(0,r.jsx)(n.p,{children:"We'll expose the hash to use via a buckconfig. Our\nthings-that-produce-hashes-of-files should either use the config to choose how\nthey hash, or fail if they cannot provide the right hash format (e.g. that'll be\ntrue of Eden I/O)."}),"\n",(0,r.jsx)(n.h3,{id:"hashes-of-directories",children:"Hashes of directories"}),"\n",(0,r.jsx)(n.p,{children:"This one gets a little tricky. Our directories currently have an implementation\nof fingerprinting that receives only the directory as input, so some refactoring\nis in order."}),"\n",(0,r.jsx)(n.p,{children:"We have two options:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pick the hashing algorithm based on the contents of the directory (pick one\nthat's already used). Dealing with empty directories is a bit annoying."}),"\n",(0,r.jsx)(n.li,{children:"Refactor the directory implementation and have directories parameterized over\ntheir fingerprints, not their hasher."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The first one is easier but has the downside of not working with keyed Blake3\n(because you don't have a way to bring in the key), so I'm aiming for the second\nimplementation for now."})]})}function d(e={}){const{wrapper:n}={...(0,i.useMDXComponents)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},15680:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>c,MDXProvider:()=>p,mdx:()=>g,useMDXComponents:()=>d,withMDXComponents:()=>h});var r=t(96540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(){return s=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},s.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=r.createContext({}),h=function(e){return function(n){var t=d(n.components);return r.createElement(e,s({},n,{components:t}))}},d=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=d(e.components);return r.createElement(c.Provider,{value:n},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,s=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=d(t),p=i,u=h["".concat(o,".").concat(p)]||h[p]||f[p]||s;return t?r.createElement(u,a(a({ref:n},c),{},{components:t})):r.createElement(u,a({ref:n},c))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var s=t.length,o=new Array(s);o[0]=m;var a={};for(var l in n)hasOwnProperty.call(n,l)&&(a[l]=n[l]);a.originalType=e,a[u]="string"==typeof e?e:i,o[1]=a;for(var c=2;c<s;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);