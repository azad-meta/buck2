"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4229],{92414:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>i});var a=r(74848),o=r(15680);const t={id:"heaps"},s="Heaps and Heap References",l={id:"developers/starlark/heaps",title:"Heaps and Heap References",description:"Heaps",source:"@site/../docs/developers/starlark/heaps.generated.md",sourceDirName:"developers/starlark",slug:"/developers/starlark/heaps",permalink:"/docs/developers/starlark/heaps",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"heaps"},sidebar:"main",previous:{title:"A Moving Garbage Collector",permalink:"/docs/developers/starlark/gc"},next:{title:"Starlark Language Specification",permalink:"/docs/developers/starlark/spec"}},c={},i=[{value:"Heaps",id:"heaps",level:2},{value:"Heap Containers",id:"heap-containers",level:2},{value:"Heap References",id:"heap-references",level:2},{value:"<code>OwnedFrozenValue</code>",id:"ownedfrozenvalue",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.useMDXComponents)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"heaps-and-heap-references",children:"Heaps and Heap References"})}),"\n",(0,a.jsx)(n.h2,{id:"heaps",children:"Heaps"}),"\n",(0,a.jsx)(n.p,{children:"In Starlark, there are three interesting heap-related points of interest:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.code,{children:"Heap"})," has ",(0,a.jsx)(n.code,{children:"Value"}),"'s allocated on it and cannot be cloned or shared."]}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.code,{children:"FrozenHeap"})," has ",(0,a.jsx)(n.code,{children:"FrozenValue"}),"'s allocated on it and cannot be cloned or\nshared."]}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.code,{children:"FrozenHeapRef"})," is a ",(0,a.jsx)(n.code,{children:"FrozenHeap"})," that is now read-only and can now be\ncloned and shared."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"FrozenHeapRef"})," keeps a heap alive. While you have a ",(0,a.jsx)(n.code,{children:"FrozenValue"}),", it is\nimportant that you have either the ",(0,a.jsx)(n.code,{children:"FrozenHeap"})," itself, or more usually, a\n",(0,a.jsx)(n.code,{children:"FrozenHeapRef"})," to it. A ",(0,a.jsx)(n.code,{children:"FrozenHeap"})," may contains a set of ",(0,a.jsx)(n.code,{children:"FrozenHeapRef"}),"'s to\nkeep the ",(0,a.jsx)(n.code,{children:"FrozenHeap"}),"s it references alive."]}),"\n",(0,a.jsx)(n.h2,{id:"heap-containers",children:"Heap Containers"}),"\n",(0,a.jsx)(n.p,{children:"Heaps are included in other data types:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.code,{children:"Module"})," contains a ",(0,a.jsx)(n.code,{children:"Heap"})," (where normal values are allocated) and a\n",(0,a.jsx)(n.code,{children:"FrozenHeap"})," (stores references to other frozen heaps and has compilation\nconstants allocated on it). The ",(0,a.jsx)(n.code,{children:"Heap"})," portion is garbage collected. At the\nend, when you call ",(0,a.jsx)(n.code,{children:"freeze"}),", ",(0,a.jsx)(n.code,{children:"Value"}),"'s referenced by name in the ",(0,a.jsx)(n.code,{children:"Module"})," are\nmoved to the ",(0,a.jsx)(n.code,{children:"FrozenHeap"})," and then then ",(0,a.jsx)(n.code,{children:"FrozenHeap"})," is sealed to produce a\n",(0,a.jsx)(n.code,{children:"FrozenHeapRef"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.code,{children:"FrozenModule"})," contains a ",(0,a.jsx)(n.code,{children:"FrozenHeapRef"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.code,{children:"GlobalsBuilder"})," contains a ",(0,a.jsx)(n.code,{children:"FrozenHeap"})," onto which values are allocated."]}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.code,{children:"Globals"})," contains a ",(0,a.jsx)(n.code,{children:"FrozenHeapRef"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"heap-references",children:"Heap References"}),"\n",(0,a.jsxs)(n.p,{children:["It is important that when a ",(0,a.jsx)(n.code,{children:"FrozenValue"})," X is referenced by a ",(0,a.jsx)(n.code,{children:"Value"})," or\n",(0,a.jsx)(n.code,{children:"FrozenValue"})," (for example, included in a list), the heap where X originates is\nadded as a reference to the heap where the new value is being created."]}),"\n",(0,a.jsx)(n.p,{children:"As a concrete example in pseudo-code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let h1 = FrozenHeap::new();\nlet s = "test".alloc(h1);\nlet h1 : FrozenHeapRef = h1.into_ref();\n\nlet h2 = Heap::new();\nh2.add_reference(h1);\nvec![s].alloc(h2);\n'})}),"\n",(0,a.jsx)(n.p,{children:"In the above code, the following steps are taken:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Create a ",(0,a.jsx)(n.code,{children:"FrozenHeap"})," then allocate something in it."]}),"\n",(0,a.jsx)(n.li,{children:"Turn the heap into a reference."}),"\n",(0,a.jsxs)(n.li,{children:["Use the allocated value ",(0,a.jsx)(n.code,{children:"s"})," from ",(0,a.jsx)(n.code,{children:"h1"})," when constructing a value in ",(0,a.jsx)(n.code,{children:"h2"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["For that to be legal, and for the heap ",(0,a.jsx)(n.code,{children:"h1"})," to not disappear while it is\nbeing allocated, it is important to call ",(0,a.jsx)(n.code,{children:"add_reference"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Note that this API can only point at a ",(0,a.jsx)(n.code,{children:"FrozenValue"})," from another heap, and only\nafter that heap has been turned into a reference, so it will not be allocated in\nanymore. These restrictions are deliberate and mean that most programs only have\none 'active heap' at a time."]}),"\n",(0,a.jsx)(n.p,{children:"Following are some places where heap references are added by Starlark:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Before evaluation is started, a reference is added to the ",(0,a.jsx)(n.code,{children:"Globals"})," from the\n",(0,a.jsx)(n.code,{children:"Module"}),", so it can access the global functions."]}),"\n",(0,a.jsxs)(n.li,{children:["When evaluating a ",(0,a.jsx)(n.code,{children:"load"})," statement, a reference is added to the ",(0,a.jsx)(n.code,{children:"FrozenModule"}),"\nthat is being loaded."]}),"\n",(0,a.jsxs)(n.li,{children:["When freezing a module, the ",(0,a.jsx)(n.code,{children:"FrozenHeap"}),", in the ",(0,a.jsx)(n.code,{children:"Module"}),", is moved to the\n",(0,a.jsx)(n.code,{children:"FrozenModule"}),", preserving the references that were added."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"ownedfrozenvalue",children:(0,a.jsx)(n.code,{children:"OwnedFrozenValue"})}),"\n",(0,a.jsxs)(n.p,{children:["When you get a value from a ",(0,a.jsx)(n.code,{children:"FrozenModule"}),", it will be a ",(0,a.jsx)(n.code,{children:"OwnedFrozenValue"}),".\nThis structure is a pair of a ",(0,a.jsx)(n.code,{children:"FrozenHeapRef"})," and a ",(0,a.jsx)(n.code,{children:"FrozenValue"}),", where the ref\nkeeps the value alive. You can move that ",(0,a.jsx)(n.code,{children:"OwnedFrozenValue"})," into the value of a\nmodule with code such as:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'fn move<\'v>(from: &FrozenModule, to: &\'v Module) {\n    let x : OwnedFrozenValue = from.get("value").unwrap();\n    let v : Value<\'v> = x.owned_value(&to);\n    to.set("value", v);\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In general, you can use the ",(0,a.jsx)(n.code,{children:"OwnedFrozenValue"})," in one of three ways:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Operate on it directly"})," - with methods like ",(0,a.jsx)(n.code,{children:"unpack_i32"})," or ",(0,a.jsx)(n.code,{children:"to_str"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Extract it safely"})," - using methods like ",(0,a.jsx)(n.code,{children:"owned_frozen_value"}),", which takes a\n",(0,a.jsx)(n.code,{children:"FrozenHeap"})," to which the heap reference is added and returns a naked\n",(0,a.jsx)(n.code,{children:"FrozenValue"}),". After that, it is then safe for the ",(0,a.jsx)(n.code,{children:"FrozenHeap"})," you passed in\nto use the ",(0,a.jsx)(n.code,{children:"FrozenValue"}),".","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["With ",(0,a.jsx)(n.code,{children:"owned_value"}),", there is lifetime checking that the right heap is\npassed, but with ",(0,a.jsx)(n.code,{children:"FrozenValue"}),", there isn't."]}),"\n",(0,a.jsx)(n.li,{children:"Be careful to pass the right heap, although given most programs only have\none active heap at a time, it should mostly work out."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Extract it unsafely"})," - using methods ",(0,a.jsx)(n.code,{children:"unchecked_frozen_value"}),", which gives\nyou the underlying ",(0,a.jsx)(n.code,{children:"FrozenValue"})," without adding any references.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Be careful to make sure there is a good reason the ",(0,a.jsx)(n.code,{children:"FrozenValue"})," remains\nvalid."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.useMDXComponents)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},15680:(e,n,r)=>{r.r(n),r.d(n,{MDXContext:()=>i,MDXProvider:()=>p,mdx:()=>f,useMDXComponents:()=>h,withMDXComponents:()=>d});var a=r(96540);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function t(){return t=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(e[a]=r[a])}return e},t.apply(this,arguments)}function s(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?s(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function c(e,n){if(null==e)return{};var r,a,o=function(e,n){if(null==e)return{};var r,a,o={},t=Object.keys(e);for(a=0;a<t.length;a++)r=t[a],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(a=0;a<t.length;a++)r=t[a],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var i=a.createContext({}),d=function(e){return function(n){var r=h(n.components);return a.createElement(e,t({},n,{components:r}))}},h=function(e){var n=a.useContext(i),r=n;return e&&(r="function"==typeof e?e(n):l(l({},n),e)),r},p=function(e){var n=h(e.components);return a.createElement(i.Provider,{value:n},e.children)},u="mdxType",j={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},x=a.forwardRef((function(e,n){var r=e.components,o=e.mdxType,t=e.originalType,s=e.parentName,i=c(e,["components","mdxType","originalType","parentName"]),d=h(r),p=o,u=d["".concat(s,".").concat(p)]||d[p]||j[p]||t;return r?a.createElement(u,l(l({ref:n},i),{},{components:r})):a.createElement(u,l({ref:n},i))}));function f(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var t=r.length,s=new Array(t);s[0]=x;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[u]="string"==typeof e?e:o,s[1]=l;for(var i=2;i<t;i++)s[i]=r[i];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}x.displayName="MDXCreateElement"}}]);